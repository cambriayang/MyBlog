---
layout: post
title: 面试总结
category: Interview
date: 2020-08-11 22:1:00 +0800
tags: [面试]
---
一些iOS的面试记录

## 如何访问并修改一个类的私有属性

+ KVC
+ runtime

创建一个Father类,声明一个私有属性name,并重写description打印name的值,在另外一个类中通过runtime来获取并修改Father中的属性

```objc
#import <objc/runtime.h>

@interface Father : NSObject
@property(nonatomic, copy) NSString *name;
@end

@implementation Father

- (NSString *)description {
    return [NSString stringWithFormat:@"name: %@", _name];
}

@end

  @interface ViewController ()

@end

@implementation ViewController

- (void)viewDidLoad {
    [super viewDidLoad];
    
    Father *father = [Father new];
    father.name = @"hey";
    NSLog(@"**%@", [father description]);
    //count记录变量数量，IVar是runtime声明的一个宏
    unsigned int count = 0;
    //获取类所有的变量
    Ivar *members = class_copyIvarList([Father class], &count);
    
    for (int i = 0; i < count; i++) {
        Ivar ivar = members[i];
        //将Ivar变量转化为字符串，这里获得属性名
        const char *memberName = ivar_getName(ivar);
        NSLog(@"==%s", memberName);
        
        Ivar m_name = members[0];
        //修改属性值
        object_setIvar(father, m_name, @"zhangsan");
        NSLog(@"[[%@", [father description]);
    }
}
 
@end
```

+ 结果

>**2020-08-11 22:50:52.448854+0800 Test[6178:13104159] \**name: hey**
>
>**2020-08-11 22:50:52.449109+0800 Test[6178:13104159] ==_name**
>
>**2020-08-11 22:50:52.449319+0800 Test[6178:13104159] [[name: zhangsan**



## +load和+initialize的区别

+  +(void)load;
  + 当类对象被引入项目时，runtime会向每一个类对象发送load消息，load方法会在每一个类甚至分类被引入时仅调用一次，调用的顺序：父类优先于子类，子类优先于分类
  + load方法不会被类自动继承
+ +(void)initialize;
  + 也是第一次使用这个类的时候会调用这个方法

##  meta-class

是Class对象的类，为这个Class类存储类方法，当一个类发送消息时，就去那个类对应的meta-class中查找那个消息

## UIView和CALayer之间的关系

+ UIView显示在屏幕上归功于CALayer，通过调用drawRect方法来渲染自身的内容，调节CALayer属性可以调整UIView的外观，UIView继承UIResponder，CALayer不可以响应用户事件
+ UIView是iOS系统中界面元素的基础，所有界面元素都继承自它。它内部是由Core Animation来实现的，它真正绘图部分，是由一个叫CALayer（Core Animation Layer）的类来管理。UIView本身，更像一个CALayer的管理器，访问它的根绘图和坐标有关的属性，如frame，bounds等，实际上内部都是访问它所在CALayer的相关属性
+ UIView有个layer属性，可以返回它的主CALayer实例，UIView有一个layerClass方法，返回主layer所使用的类，UIView的子类，可以通过重载这个方法，来让UiView使用不同的CALayer来显示

## Push Notification是如何工作的

+ 推送分为两种，本地推送和远程推送
  + 本地推送：不需要联网，是开发人员在app内设定特定的时间来提醒用户干什么
  + 远程推送：需要联网，用户的设备会于苹果APNS服务器形成一个长连接，用户设备会发送uuid和bundle id给苹果服务器，苹果服务器会加密生成一个deviceToken给用户设备，然后设备会将deviceToken发送给app服务器，服务器会将deviceToken存进他们的数据库，这时候如果有人发送消息给我，服务器端就会去查询我的deviceToken，然后将deviceToken和要发送的消息发送给苹果服务器，苹果服务器通过deviceToken找到我的设备并将消息推送到我的设备上，这里还有个情况是如果app在线，那么app服务器会于app产生一个长连接，这时候app服务器会直接通过deviceToken将消息推送到设备上
+ runloop

是一个与线程相关的机制，可以理解为一个循环，在这个循环里面等待事件然后处理事件。而这个循环是基于线程的，在Cocoa中每个线程都有它的runloop，通过这样的机制，线程可以在没有事件要处理的时候休息，有时间运行，减轻cpu压力。